Q1
Given the AST declarations as follows:

class Program: #decl:List[VarDecl],exp:Exp

class VarDecl: #name:str,typ:Type

class Type(ABC): #abstract class

class IntType(Type)

class FloatType(Type)

class BoolType(Type)

class Exp(ABC): #abstract class

class BinOp(Exp): #op:str,e1:Exp,e2:Exp #op is +,-,*,/,&&,||, >, <, ==, or  !=

class UnOp(Exp): #op:str,e:Exp #op is -, !

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitIntType(self,ctx:IntType,o):pass

    def visitFloatType(self,ctx:FloatType,o):pass

    def visitBoolType(self,ctx:BoolType,o):pass

    def visitBinOp(self,ctx:BinOp,o): pass

    def visitUnOp(self,ctx:UnOp,o):pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to check the following type constraints:

    + , - and * accept their operands in int or float type and return float type if at least one of their operands is in float type, otherwise, return int type
    / accepts their operands in int or float type and returns float type
    !, && and || accept their operands in bool type and return bool type
    >, <, == and != accept their operands in any type but must in the same type and return bool type
    the type of an Id is from the declarations, if the Id is not in the declarations, exception UndeclaredIdentifier should be raised with the name of the Id. 

If the expression does not conform the type constraints, the StaticCheck will raise exception TypeMismatchInExpression with the innermost sub-expression that contains type mismatch.

class StaticCheck(Visitor):
    
    def visitProgram(self,ctx:Program,o:object):
        self.visit(ctx.exp,ctx.decl)

    def visitVarDecl(self,ctx:VarDecl,o:object):pass

    def visitIntType(self,ctx:IntType,o):pass

    def visitFloatType(self,ctx:FloatType,o):pass

    def visitBoolType(self,ctx:BoolType,o):pass
    
    def visitBinOp(self,ctx:BinOp,o):
        operand1 = self.visit(ctx.e1,o)
        operand2 = self.visit(ctx.e2,o)
        if ctx.op == '+' or ctx.op == '-' or ctx.op == '*':
            if operand1 == 2 or operand2 == 2:
                raise TypeMismatchInExpression(ctx)
            if operand1 == 1 or operand2 == 1:
                return 1
            return 0
        elif ctx.op == '/':
            if operand1 == 2 or operand2 == 2:
                raise TypeMismatchInExpression(ctx)
            return 1
        elif ctx.op == '&&' or ctx.op == '||':
            if operand1 != 2 or operand2 != 2:
                raise TypeMismatchInExpression(ctx)
            return 2
        elif ctx.op == '>' or ctx.op == '<' or ctx.op == '==' or ctx.op == '!=':
            if operand1 != operand2:
                raise TypeMismatchInExpression(ctx)
            return 2

    def visitUnOp(self,ctx:UnOp,o):
        operand = self.visit(ctx.e,o)
        if ctx.op == '-':
            if operand == 2:
                raise TypeMismatchInExpression(ctx)
            return operand
        elif ctx.op == '!':
            if operand != 2:
                raise TypeMismatchInExpression(ctx)
            return operand
        
    def visitIntLit(self,ctx:IntLit,o):
        return 0

    def visitFloatLit(self,ctx,o):
        return 1

    def visitBoolLit(self,ctx,o):
        return 2

    def visitId(self,ctx,o):
        for var in o:
            if ctx.name == var.name:
                if type(var.typ) == IntType:
                    return 0
                if type(var.typ) == FloatType:
                    return 1
                if type(var.typ) == BoolType:
                    return 2
        raise UndeclaredIdentifier(ctx.name) 

Q2
Given the AST declarations as follows:

class Exp(ABC): #abstract class

class BinOp(Exp): #op:str,e1:Exp,e2:Exp #op is +,-,*,/,&&,||, >, <, ==, or  !=

class UnOp(Exp): #op:str,e:Exp #op is -, !

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitBinOp(self,ctx:BinOp,o): pass

    def visitUnOp(self,ctx:UnOp,o):pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to check the following type constraints:

    + , - and * accept their operands in int or float type and return float type if at least one of their operands is in float type, otherwise, return int type
    / accepts their operands in int or float type and returns float type
    !, && and || accept their operands in bool type and return bool type
    >, <, == and != accept their operands in any type but must in the same type and return bool type 

If the expression does not conform the type constraints, the StaticCheck will raise exception TypeMismatchInExpression with the innermost sub-expression that contains type mismatch.

class StaticCheck(Visitor):

    def visitBinOp(self,ctx:BinOp,o):
        operand1 = self.visit(ctx.e1,o)
        operand2 = self.visit(ctx.e2,o)
        if ctx.op == '+' or ctx.op == '-' or ctx.op == '*':
            if operand1 == 2 or operand2 == 2:
                raise TypeMismatchInExpression(ctx)
            if operand1 == 1 or operand2 == 1:
                return 1
            return 0
        elif ctx.op == '/':
            if operand1 == 2 or operand2 == 2:
                raise TypeMismatchInExpression(ctx)
            return 1
        elif ctx.op == '&&' or ctx.op == '||':
            if operand1 != 2 or operand2 != 2:
                raise TypeMismatchInExpression(ctx)
            return 2
        elif ctx.op == '>' or ctx.op == '<' or ctx.op == '==' or ctx.op == '!=':
            if operand1 != operand2:
                raise TypeMismatchInExpression(ctx)
            return 2

    def visitUnOp(self,ctx:UnOp,o):
        operand = self.visit(ctx.e,o)
        if ctx.op == '-':
            if operand == 2:
                raise TypeMismatchInExpression(ctx)
            return operand
        elif ctx.op == '!':
            if operand != 2:
                raise TypeMismatchInExpression(ctx)
            return operand
        
    def visitIntLit(self,ctx:IntLit,o):
        return 0

    def visitFloatLit(self,ctx,o):
        return 1

    def visitBoolLit(self,ctx,o):
        return 2

Q3
Given the AST declarations as follows:

class Program: #decl:List[VarDecl],stmts:List[Assign]

class VarDecl: #name:str

class Assign: #lhs:Id,rhs:Exp

class Exp(ABC): #abstract class

class BinOp(Exp): #op:str,e1:Exp,e2:Exp #op is +,-,*,/,+.,-.,*.,/., &&,||, >, >., >b, =, =., =b

class UnOp(Exp): #op:str,e:Exp #op is -,-., !,i2f, floor

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitAssign(self,ctx:Assign,o): pass

    def visitBinOp(self,ctx:BinOp,o): pass

    def visitUnOp(self,ctx:UnOp,o):pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to infer the type of identifiers and check the following type constraints:

    + , - , *, / accept their operands in int type and return int type
    +., -., *., /. accept their operands in float type and return float type
    > and = accept their operands in int type and return bool type
    >. and =. accept their operands in float type and return bool type
    !, &&, ||, >b and =b accept their operands in bool type and return bool type
    i2f accepts its operand in int type and return float type
    floor accept its operand in float type and return int type
    In an assignment statement, the type of lhs must be the same as that of rhs, otherwise, the exception TypeMismatchInStatement should be raised together with the assignment statement.
    the type of an Id is inferred from the above constraints in the first usage, 
        if the Id is not in the declarations, exception UndeclaredIdentifier should be raised together with the name of the Id, or
        If the Id cannot be inferred in the first usage, exception TypeCannotBeInferred should be raised together with the name of the assignment statement.
    If an expression does not conform the type constraints, the StaticCheck will raise exception TypeMismatchInExpression with the expression.

class StaticCheck(Visitor):
    
    def visitProgram(self,ctx:Program,o:object):
        o = {}
        for decl in ctx.decl:
            self.visit(decl,o)
        for stmt in ctx.stmts:
            self.visit(stmt,o)


    def visitVarDecl(self,ctx:VarDecl,o:object):
        o[ctx.name] = "none"

    def visitAssign(self,ctx:Assign,o):
        right = self.visit(ctx.rhs,o)
        left = self.visit(ctx.lhs, o)
        if left == "none" and right == "none":
            raise TypeCannotBeInferred(ctx)
        if left == "none":
            o[ctx.lhs.name] = right
            left = right
        elif right == "none":
            o[ctx.rhs.name] = left
            right = left
        elif left != right:
            raise TypeMismatchInStatement(ctx)
    
    def visitBinOp(self,ctx:BinOp,o):
        left = self.visit(ctx.e1,o)
        right = self.visit(ctx.e2,o)

        if ctx.op == '+' or ctx.op == '-' or ctx.op == '*' or ctx.op == '/':
            if left == "none":
                o[ctx.e1.name] = "int"
                left = "int"
            if right == "none":
                o[ctx.e2.name] = "int"
                right = "int"
            if left == "int" and right == "int":
                return "int"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op in '+.' or ctx.op == '-.' or ctx.op == '*.' or ctx.op == '/.':
            if left == "none":
                o[ctx.e1.name] = "float"
                left = "float"
            if right == "none":
                o[ctx.e2.name] = "float"
                right = "float"
            if left == "float" and right == "float":
                return "float"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == '>' or ctx.op == '=':
            if left == "none":
                o[ctx.e1.name] = "int"
                left = "int"
            if right == "none":
                o[ctx.e2.name] = "int"
                right = "int"
            if left == "int" and right == "int":
                return "bool"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == '>.' or ctx.op == '=.':
            if left == "none":
                o[ctx.e1.name] = "float"
                left = "float"
            if right == "none":
                o[ctx.e2.name] = "float"
                right = "float"
            if left == "float" and right == "float":
                return "bool"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == '&&' or ctx.op == '||' or ctx.op == '>b' or ctx.op == "=b":
            if left == "none":
                o[ctx.e1.name] = "bool"
                left = "bool"
            if right == "none":
                o[ctx.e2.name] = "bool"
                right = "bool"
            if left == "bool" and right == "bool":
                return "bool"
            raise TypeMismatchInExpression(ctx)

    def visitUnOp(self,ctx:UnOp,o):
        typ = self.visit(ctx.e,o)
        if ctx.op == "-":
            if typ == "none":
                o[ctx.e.name] = "int"
                typ = "int"
            if typ == "int":
                return "int"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == "-.":
            if typ == "none":
                o[ctx.e.name] = "float"
                typ = "float"
            if typ == "float":
                return "float"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == "!":
            if typ == "none":
                o[ctx.e.name] = "bool"
                typ = "bool"
            if typ == "bool":
                return "bool"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == "i2f":
            if typ == "none":
                o[ctx.e.name] = "int"
                typ = "int"
            if typ == "int":
                return "float"
            raise TypeMismatchInExpression(ctx)
        elif ctx.op == "floor":
            if typ == "none":
                o[ctx.e.name] = "float"
                typ = "float"
            if typ == "float":
                return "int"
            raise TypeMismatchInExpression(ctx)

    def visitIntLit(self,ctx:IntLit,o):
        return "int"

    def visitFloatLit(self,ctx,o):
        return "float"

    def visitBoolLit(self,ctx,o):
        return "bool"
        
    def visitId(self,ctx,o):
        if ctx.name in o:
            return o[ctx.name]
        raise UndeclaredIdentifier(ctx.name)
 
Q4
Given the AST declarations as follows:

class Program: #decl:List[VarDecl],stmts:List[Stmt]

class VarDecl: #name:str

class Stmt(ABC): #abstract class

class Block(Stmt): #decl:List[VarDecl],stmts:List[Stmt]

class Assign(Stmt): #lhs:Id,rhs:Exp

class Exp(ABC): #abstract class

class BinOp(Exp): #op:str,e1:Exp,e2:Exp #op is +,-,*,/,+.,-.,*.,/., &&,||, >, >., >b, =, =., =b

class UnOp(Exp): #op:str,e:Exp #op is -,-., !,i2f, floor

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitBlock(self,ctx:Block,o): pass

    def visitAssign(self,ctx:Assign,o): pass

    def visitBinOp(self,ctx:BinOp,o): pass

    def visitUnOp(self,ctx:UnOp,o):pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to infer the type of identifiers and check the following type constraints:

    + , - , *, / accept their operands in int type and return int type
    +., -., *., /. accept their operands in float type and return float type
    > and = accept their operands in int type and return bool type
    >. and =. accept their operands in float type and return bool type
    !, &&, ||, >b and =b accept their operands in bool type and return bool type
    i2f accepts its operand in int type and return float type
    floor accept its operand in float type and return int type
    In an assignment statement, the type of lhs must be the same as that of rhs, otherwise, the exception TypeMismatchInStatement should be raised together with the assignment statement.
    the type of an Id is inferred from the above constraints in the first usage, 
        if the Id is not in the declarations, exception UndeclaredIdentifier should be raised together with the name of the Id, or
        If the Id cannot be inferred in the first usage, exception TypeCannotBeInferred should be raised together with the assignment statement which contains the type-unresolved identifier.
    For static referencing environment, this language applies the scope rules of block-structured programming language. When there is a declaration duplication of a name in a scope, exception Redeclared should be raised together with the second declaration.
    If an expression does not conform the type constraints, the StaticCheck will raise exception TypeMismatchInExpression with the expression.

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):
        o = [{}]
        for decl in ctx.decl:
            self.visit(decl,o)
        for stmt in ctx.stmts:
            self.visit(stmt,o)

    def visitVarDecl(self,ctx:VarDecl,o):
        n=ctx.name
        if n in o[0]:
            raise Redeclared(ctx)
        else:
            o[0][ctx.name] = "none"
    def visitBlock(self,ctx:Block,o):
        block=[{}]
        listDecl=ctx.decl
        listStmts=ctx.stmts
        for nameDecl in listDecl:
           self.visit(nameDecl,block+o)
        for nameStmt in listStmts:
           self.visit(nameStmt,block+o)
    def visitAssign(self,ctx:Assign,o):
        rhs = self.visit(ctx.rhs,o)
        lhs = self.visit(ctx.lhs, o)
        if lhs == "none":
            if rhs == "none":
                raise TypeCannotBeInferred(ctx)
            for a in o:
                if ctx.lhs.name in a:
                   a[ctx.lhs.name]=rhs
                   break
            lhs = rhs
        if rhs == "none":
            if lhs == "none":
                raise TypeCannotBeInferred(ctx)
            for a in o:
                if ctx.rhs.name in a:
                    a[ctx.rhs.name]=lhs
                    break
            rhs = lhs
        if lhs != rhs:
            raise TypeMismatchInStatement(ctx)


    def visitBinOp(self,ctx:BinOp,o):
        ltype = self.visit(ctx.e1,o)
        rtype = self.visit(ctx.e2,o)

        if ctx.op in ["+", "-", "*", "/"]:
            if ltype == "none":
                for a in o:
                    if ctx.e1.name in a:
                        a[ctx.e1.name]="int"
                        break
                ltype == "int"
            if rtype == "none":
                for a in o:
                    if ctx.e2.name in a:
                        a[ctx.e2.name]="int"
                        break
                rtype == "int"
            if ltype == "int" and rtype == "int":
                return "int"
            raise TypeMismatchInExpression(ctx)
        if ctx.op in ["+.", "-.", "*.", "/."]:
            if ltype == "none":
                for a in o:
                    if ctx.e1.name in a:
                        a[ctx.e1.name]="float"
                        break
                ltype == "float"
            if rtype == "none":
                for a in o:
                    if ctx.e2.name in a:
                        a[ctx.e2.name]="float"
                        break
                rtype == "float"
            if ltype == "float" and rtype == "float":
                return "float"
            raise TypeMismatchInExpression(ctx)
        if ctx.op in [">","="]:
            if ltype == "none":
                for a in o:
                    if ctx.e1.name in a:
                        a[ctx.e1.name]="int"
                        break
                ltype == "int"
            if rtype == "none":
                for a in o:
                    if ctx.e2.name in a:
                        a[ctx.e2.name]="int"
                        break
                rtype == "int"
            if ltype == "int" and rtype == "int":
                return "bool"
            raise TypeMismatchInExpression(ctx)
        if ctx.op in [">.", "=."]:
            if ltype == "none":
                for a in o:
                    if ctx.e1.name in a:
                        a[ctx.e1.name]="float"
                        break
                ltype == "float"
            if rtype == "none":
                for a in o:
                    if ctx.e2.name in a:
                        a[ctx.e2.name]="float"
                        break
                rtype == "float"
            if ltype == "float" and rtype == "float":
                return "bool"
            raise TypeMismatchInExpression(ctx)
        if ctx.op in ["&&", "||", ">b", "=b"]:
            if ltype == "none":
                for a in o:
                    if ctx.e1.name in a:
                        a[ctx.e1.name]="bool"
                        break
                ltype == "bool"
            if rtype == "none":
                for a in o:
                    if ctx.e1.name in a:
                        a[ctx.e1.name]="bool"
                        break
                rtype == "bool"
            if ltype == "bool" and rtype == "bool":
                return "bool"
            raise TypeMismatchInExpression(ctx)

    def visitUnOp(self,ctx:UnOp,o):
        typ = self.visit(ctx.e,o)
        if ctx.op == "-":
            if typ == "none":
                for a in o:
                    if ctx.e.name in a:
                        a[ctx.e.name]="int"
                        break
                typ == "int"
            if typ == "int":
                return "int"
            raise TypeMismatchInExpression(ctx)
        if ctx.op == "-.":
            if typ == "none":
                for a in o:
                    if ctx.e.name in a:
                        a[ctx.e.name]="float"
                        break
                typ == "float"
            if typ == "float":
                return "float"
            raise TypeMismatchInExpression(ctx)
        if ctx.op == "!":
            if typ == "none":
                for a in o:
                    if ctx.e.name in a:
                        a[ctx.e.name]="bool"
                        break
                typ == "bool"
            if typ == "bool":
                return "bool"
            raise TypeMismatchInExpression(ctx)
        if ctx.op == "i2f":
            if typ == "none":
                for a in o:
                    if ctx.e.name in a:
                        a[ctx.e.name]="int"
                        break
                typ == "int"
            if typ == "int":
                return "float"
            raise TypeMismatchInExpression(ctx)
        if ctx.op == "floor":
            if typ == "none":
                for a in o:
                    if ctx.e.name in a:
                        a[ctx.e.name]="float"
                        break
                typ == "float"
            if typ == "float":
                return "int"
            raise TypeMismatchInExpression(ctx)

    def visitIntLit(self,ctx:IntLit,o):
        return "int"

    def visitFloatLit(self,ctx,o):
        return "float"

    def visitBoolLit(self,ctx,o):
        return "bool"

    def visitId(self,ctx,o):
        n = ctx.name
        for a in o:
            if n in a:
                return a[n]
        raise UndeclaredIdentifier(n)

Q5
Given the AST declarations as follows:

class Program: #decl:List[Decl],stmts:List[Stmt]

class Decl(ABC): #abstract class

class VarDecl(Decl): #name:str

class FuncDecl(Decl): #name:str,param:List[VarDecl],local:List[Decl],stmts:List[Stmt]

class Stmt(ABC): #abstract class

class Assign(Stmt): #lhs:Id,rhs:Exp

class CallStmt(Stmt): #name:str,args:List[Exp]

class Exp(ABC): #abstract class

class IntLit(Exp): #val:int

class FloatLit(Exp): #val:float

class BoolLit(Exp): #val:bool

class Id(Exp): #name:str

and the Visitor class is declared as follows:

class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):pass

    def visitVarDecl(self,ctx:VarDecl,o): pass

    def visitFuncDecl(self,ctx:FuncDecl,o): pass

    def visitCallStmt(self,ctx:CallStmt,o):pass

    def visitAssign(self,ctx:Assign,o): pass

    def visitIntLit(self,ctx:IntLit,o): pass 

    def visitFloatLit(self,ctx,o): pass

    def visitBoolLit(self,ctx,o): pass

    def visitId(self,ctx,o): pass

Rewrite the body of the methods in class StaticCheck to infer the type of identifiers and check the following type constraints:

    In an Assign, the type of lhs must be the same as that of rhs, otherwise, the exception TypeMismatchInStatement should be raised together with the Assign
    the type of an Id is inferred from the above constraints in the first usage, 
        if the Id is not in the declarations, exception UndeclaredIdentifier should be raised together with the name of the Id, or
        If the Id cannot be inferred in the first usage, exception TypeCannotBeInferred should be raised together with the statement
    For static referencing environment, this language applies the scope rules of block-structured programming language where a function is a block. When there is a declaration duplication of a name in a scope, exception Redeclared should be raised together with the second declaration.
    In a call statement, the argument type must be the same as the parameter type. If there is no function declaration in the static referencing environment, exception UndeclaredIdentifier should be raised together with the function call name. If the numbers of parameters and arguments are not the same or at least one argument type is not the same as the type of the corresponding parameter, exception TypeMismatchInStatement should be raise with the call statement. If there is at least one parameter type cannot be resolved, exception TypeCannotBeInferred should be raised together with the call statement.

def infer(name,typ,o):
    for env in o:
        if name in env:
            env[name] = typ
            return
            
class StaticCheck(Visitor):

    def visitProgram(self,ctx:Program,o):
        o = [{}]
        [self.visit(decl,o) for decl in ctx.decl ]
        [self.visit(stmt,o) for stmt in ctx.stmts]

    def visitVarDecl(self,ctx:VarDecl,o): 
        if ctx.name in o[0]:
            raise Redeclared(ctx)
        o[0][ctx.name] = 0

    def visitFuncDecl(self,ctx:FuncDecl,o): 
        if ctx.name in o[0]:
            raise Redeclared(ctx)
        env = [{}] + o
        [self.visit(decl,env) for decl in ctx.param ]
        nParam = len(env[0])
        [self.visit(decl,env) for decl in ctx.local ]
        [self.visit(stmt,env) for stmt in ctx.stmts ]
        param = list(env[0].values())[:nParam]
        o[0][ctx.name] = param
        
    def visitCallStmt(self,ctx:CallStmt,o):
        param = None
        for env in o:
            if ctx.name in env:
                if type(env[ctx.name]) is list: 
                    param = env[ctx.name]                
        if param == None:
            raise UndeclaredIdentifier(ctx.name)
        args = [self.visit(arg,o) for arg in ctx.args]   
        if len(args) > len(param):
            raise TypeMismatchInStatement(ctx)
        for i in range(len(param)):
            if args[i] == 0 and param[i] == 0:
                raise TypeCannotBeInferred(ctx)
            elif args[i] == 0:
                infer(ctx.args[i].name,param[i],o)
            elif param[i] == 0:
                for env in o:
                    if ctx.name in env:
                        env[ctx.name][i] = args[i]
            elif args[i] != param[i]:
                raise TypeMismatchInStatement(ctx) 
        
    def visitAssign(self,ctx:Assign,o): 
        rhs = self.visit(ctx.rhs,o)
        lhs = self.visit(ctx.lhs,o)
        if lhs == 0 and rhs == 0:
            raise TypeCannotBeInferred(ctx)
        if lhs == 0:
            lhs = rhs
            infer(ctx.lhs.name,rhs,o)
        if rhs == 0:
            rhs = lhs
            infer(ctx.rhs.name,lhs,o)
        if lhs != rhs:
            raise TypeMismatchInStatement(ctx)

    def visitIntLit(self,ctx:IntLit,o): 
        return 1

    def visitFloatLit(self,ctx,o): 
        return 2

    def visitBoolLit(self,ctx,o): 
        return 3

    def visitId(self,ctx,o): 
        for env in o:
            if ctx.name in env:
                if type(env[ctx.name]) is not list: 
                    return env[ctx.name]
        raise UndeclaredIdentifier(ctx.name)